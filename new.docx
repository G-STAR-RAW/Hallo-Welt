hello
Java基础
1	Java基本数据类型介绍
  
除了double和long之外，对其他基本数据类型的操作都是原子性的。而对于double和long，两种类型都是8个字节64位，在32位操作系统的环境下，一次操作只能读取32位，无法一次性读取double和long数据，多线程环境下可能导致数据读写错误。
2	Java面向对象三大特性
	封装
将一个对象的属性私有化，同时提供一些能被外界访问的public方法。
	继承
子类继承父类的属性和方法，在此基础上，可在子类中对父类的方法进行重写，也可基于父类方法增加新的属性或功能。
	多态 
父类型的引用指向子类型的对象。程序运行中时，父类型的引用指向不同子类型的对象时，可能会产生不同的结果。
3	Java泛型中的E、T、K、V的含义
E：Element，在集合中使用，因为集合中存放的是元素。
T：Type，Java类。
K：Key，键。
V：Value，值。
N：Number，数值类型。
3.1	泛型类
  
3.2	泛型方法
  
3.3	泛型接口
  

4	类加载过程和变量加载顺序
类加载：描述类的数据从class文件加载到内存，并且对数据进行校验、解析和初始化。
4.1	类加载触发时机
	使用new关键字实例化对象；
	读取一个类的静态变量；
	调用类的静态方法；
	反射；
	初始化子类时，会先初始化父类；
	虚拟机启动时，优先初始化main()所在的类。
4.2	类加载过程
	加载：
通过类的全限定名来获取此类的二进制字节流；
将字节流代表的静态存储结构转换成方法区的运行时数据结构；
在内存中生成该类的class对象，作为方法区这个类各种数据的访问入口。
	验证：
确保class文件的字节流中包含的信息是否符合虚拟机的要求，并且不会有害于虚拟机。
	准备：
为类变量分配内存并设置初始值（零值）。
	解析：
将常量池的符号引用替换为直接引用(直接指针、句柄)的过程。
	初始化
为类变量、静态代码块初始化（赋值），执行构造函数。
4.3	变量初始化顺序
父类、子类：加载子类的时候会优先加载父类。
父类静态变量/父类静态代码块（这两个顺序由代码顺序决定）
子类静态变量/子类静态代码块
父类变量/父类代码块
父类构造函数
子类变量/子类代码块
子类构造函数

父类子类
静态变量/静态代码块普通变量/普通代码块构造函数
5	双亲委派模型
 
类加载器：通过一个类的全限定名来获取此类的二进制字节流；
任何一个类都是由这个类本身和加载这个类的类加载器来确定类在JVM中的唯一性。
5.1	工作原理
	如果一个类收到了类加载请求，首先会判断当前类是否已经被加载，若已被加载，则直接返回；若未被加载，则将类加载请求委托给父类加载器去执行，如果父类加载器还有父类加载器，则继续向上委托。如果父类加载器无法加载当前类，才会将加载任务交给子类去执行。
5.2	启动类加载器(Bootstrap ClassLoader)
主要负责加载<JAVA_HOME>\lib目录中或被-Xbootclasspath指定的路径中的并且文件名是被虚拟机识别的文件。它等于是所有类加载器的爸爸。
5.3	扩展类加载器(Extension ClassLoader)
独立于虚拟机，主要负责加载<JAVA_HOME>\lib\ext目录中或被java.ext.dirs系统变量所指定的路径的类库。
5.4	应用程序加载器(Application ClassLoader)
负责加载用户类路径(classPath)上的类库，如果我们没有实现自定义的类加载器那这玩意就是我们程序中的默认加载器。
5.5	好处
	避免类的重复加载
	保证Java的核心API不被篡改
5.6	双亲委派为什么是先往上传到bootstrap加载器，而不是从bootstrap加载器直接往下开始尝试？
 
如果自定义类加载器存在多个，如果从bootstrap加载器往下查找，则到最底层的自定义类加载器时，就不能确定应该选择哪个自定义类加载器进行加载。
5.7	打破双亲委派模型的特例
5.7.1	JDBC
 
Class.forName()加载用的是调用者的Classloader，这个调用者DriverManager是在rt.jar中的，ClassLoader是启动类加载器，而com.mysql.jdbc.Driver肯定不在<JAVA_HOME>/lib下，所以肯定是无法加载mysql中的这个类的。这就是双亲委派模型的局限性了，父级加载器无法加载子级类加载器路径中的类。
只要在启动类加载器中有方法获取应用程序类加载器，然后通过它去加载就可以了。这就是所谓的线程上下文加载器。
线程上下文类加载器让父级类加载器能通过调用子级类加载器来加载类，这打破了双亲委派模型的原则。
5.7.2	Tomcat容器
一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。




6	线程的生命周期
 
 
以下内容或已过时。
	新建：
当创建新线程后，进入新建状态。如Thread thread = new MyThread()。
线程已创建完成，但还不能参与CPU资源的竞争。
	就绪：
新建就绪(start())，阻塞就绪(notify、notifyAll)，
运行就绪(yield或CPU时间片用完)，
调用start()后，进入就绪状态。如thread.start()。
等待CPU分配资源阶段，随时会进行CPU资源的抢夺。
	运行：
就绪运行，线程抢占到CPU的资源，执行当前线程。
	阻塞：
运行阻塞，由于某些原因使线程失去使用CPU的权利。
同步阻塞（synchronized），等待阻塞（wait），其他阻塞（sleep，join）。
	销毁：
线程执行完毕或者被强制性终止，则销毁线程，释放资源。
7	重写equals时为什么要重写hashcode？ 
Object中的equals()比较的是两个对象的地址，Object的hashcode()是一个本地方法，hash值的计算利用的是内存地址。
主要是为了应用于需要使用散列的数据结构中，例如HashMap、HashSet。
拿HashMap举例，在将key添加进HashMap中时，会先根据hashcode()计算出key的hash值，然后判断HashMap中是否存在相同hash值的key；若不存在，则将新增key添加进HashMap中，若存在，则通过equals()比较两个key是否相等。
重载hashCode()是为了对同一个key，能得到相同的hashCode，这样HashMap就可以定位到我们指定的key上。
重载equals()是为了向HashMap表明当前对象和key上所保存的对象是相等的，这样才能真正获得这个key所对应的键值对。
8	~~~Java IO相关
BIO：面向流，同步阻塞IO。服务器一个线程只处理一个客户端的连接。
	 Socket、ServerSocket
NIO：数据的读写通过Buffer缓冲区来完成。面向缓冲区，同步非阻塞IO。服务器一个线程可以处理来自多个客户端的连接。客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理。
	 Selector、SocketChannel、ServerSocketChannel。
多路复用器：在一个进程里面开辟多个通道，然后进程回去轮询准备就绪的通道，被选中的通道去进行读写操作。
8.1.1	多路复用机制
	selector模型(轮询)
 
	Poll模型(轮询)
Poll模型和selector模型没有本质区别：别在于selector模型有注册数量限制1024，而poll没有限制，因为poll是基于链表存储的。
	Epoll(事件驱动)
 

8.1.2	NIO channel和buffer
NIO的所有IO操作都是以channel开始的，NIO的channel就像BIO中的流；
可以同时对Channel进行读写操作；
Buffer可从channel读数据，也可向channel写数据。

8.1.3	NIO读文件
	获取输入流通道channel
	创建缓冲区buffer
	依次读取数据到缓冲区

9	内部类
9.1.1	成员内部类
	成员内部类可以访问外部类的所有成员属性和方法(private和静态)。
如果内部类和外部类有同名的成员变量或方法时，默认访问成员内部类的成员(就近原则)；此时，如果想在内部类里访问外部类的成员，需使用外部类.this.成员变量(方法)的形式。
	外部类访问内部类的成员变量和方法：new 内部类.方法。
	创建内部类对象：new Circle().new Draw()。
  
9.2	局部内部类
局部内部类定义在一个方法或者一个作用域内，类似于方法里的局部变量。
9.3	匿名内部类
常用于事件监听的代码里。
 
9.4	静态内部类
对比成员内部类，类似于类的静态属性，静态内部类不能使用外部类的非静态成员变量和方法。（示例：通过外部类(非new)创建静态内部类，静态内部类再去调用外部类的非静态成员，会产生矛盾，因为此时外部类并没有实例化）。

10	RandomACcess接  口
空接口，该接口为一个标志接口。实现该接口的集合(例如ArrayList)标志支持快速随机访问。

11	JDK8新特性
11.1	接口新增默认方法(default)
接口允许有实现方法，只需要在方法名前新增default关键字即可。
11.1.1	作用
为接口添加新方法，同时保证不影响已有的实现。
11.1.2	解决default方法冲突的三步骤：
	方法签名相同时，才表示出现了冲突。
	类中的方法优先级最高。类或者父类中的方法实现优先级大于任何接口的默认方法
	子接口的默认方法优先级更高。
	若最终还是无法判断，那么实现类必须通过显示复写的方式复写默认方法，然后再自己通过xxx.super.xxx()的方式来指定具体使用哪个接口的实现
11.1.3	示例
多重继承中，如果出现了同名的默认方法
   

示例1：若继承的两个接口相互独立且存在相同的默认方法，则需要重写default方法，并制定继承哪一个接口的default方法。
 		
示例2：若继承的两个接口存在相同的默认方法且为继承关系，则调用的是子类接口的default方法。
 

11.2	Lambda表达式
允许把函数作为一个方法的参数，可替换匿名内部类。
 
 

11.3	Stream
对一个集合中的一系列元素进行聚合操作，类似于RDD操作。
Stream 的一系列操作必须要使用终止操作，否者整个数据流是不会流动起来的，即处理操作不会执行。
Stream不会存储元素；
Stream不会改变源对象，会返回一个持有结果的Stream；
Stream操作是延时执行的，会等到需要结果的时候才会去真正执行。
11.3.1	中间操作符
 
11.3.2	终止操作符
 
11.3.3	示例
 
11.4	Optional 类
主要是为了解决空指针异常NullPointException问题
11.4.1	构造方法
	Optional.of(T)  
该方式的入参不能为null，否则会有NPE，在确定入参不为空时使用该方式。
	Optional.ofNullable(T)
该方式的入参可以为null，当入参不确定为非null时使用。
	Optional.empty()
这种方式是返回一个空Optional，等效Optional.ofNullable(null)
11.4.2	常用方法
	ifPresent() <==> obj != null
当Optional实例的值非空时返回true，否则返回false; 
	orElseGet()
当Optional包含非空值时返回该值，否则通过接收的function生成一个默认的；
	map()
转换当前Optional的值，并返回一个新的Optional实例；
	orElse()
与orElseGet方法相似，不同的是orElse()直接返回传入的默认值。
	orElseThrow()
	value值为null时，直接抛出一个异常
11.4.3	示例
 

